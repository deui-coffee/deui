#!/usr/bin/env node

const http = require('http')

const morgan = require('morgan')

var cors = require('cors')

const express = require('express')

const bodyParser = require('body-parser')

const app = express()

app.use(express.static('public'))

app.use(bodyParser.json())

app.use(morgan('dev'))

app.use(cors())

const { createProxyMiddleware } = require('http-proxy-middleware')

function proxyFilter(pathname, req) {
    return req.method !== 'POST' || !/^\/(scan|on|off)/.test(pathname)
}

app.use(
    createProxyMiddleware(proxyFilter, {
        target: 'http://127.0.0.1:3000',
        changeOrigin: true,
    })
)

const httpServer = http.createServer(app)

const debug = require('debug')

const info = debug('deui-server:info')

const noble = require('@abandonware/noble')

const error = debug('deui-server:error')

const { WebSocketServer } = require('ws')

const Port = process.env.PORT || 3000

app.get('/', (_, res) => {
    res.render('index')
})

httpServer.listen(Port, () => {
    info('Listening on %d…', Port)
})

const wsServer = new WebSocketServer({ noServer: true, path: '/' })

httpServer.on('upgrade', (req, socket, head) => {
    wsServer.handleUpgrade(req, socket, head, (ws) => {
        wsServer.emit('connection', ws, req)
    })
})

let State = {
    // unknown
    // resetting
    // unsupported
    // unauthorized
    // poweredOff
    // poweredOn
    bluetoothState: 'unknown',
    scanning: false,
    connecting: false,
    discoveringCharacteristics: false,
    device: undefined,
}

const properties = {}

let characteristics = {}

const ErrorCode = {
    NotPoweredOn: 1,
    AlreadyScanning: 2,
    AlreadyConnecting: 3,
    AlreadyConnected: 4,
    NotConnected: 5,
    UnknownCharacteristic: 6,
}

app.post('/scan', (_, res) => {
    if (State.bluetoothState !== 'poweredOn') {
        return void res.status(409).json({ code: ErrorCode.NotPoweredOn })
    }

    if (State.scanning) {
        return void res.status(409).json({ code: ErrorCode.AlreadyScanning })
    }

    if (State.connecting) {
        return void res.status(409).json({ code: ErrorCode.AlreadyConnecting })
    }

    if (State.device) {
        return void res.status(409).json({ code: ErrorCode.AlreadyConnected })
    }

    try {
        noble.startScanning([], false)

        res.status(200).json({})
    } catch (e) {
        error('startScanning error', e)

        res.status(503).end()
    }
})

function sendProperties(webSocket, payload) {
    webSocket.send(
        JSON.stringify({
            type: 'properties',
            payload,
        })
    )
}

function setCharacteristicValue(uuid, data) {
    let payload

    switch (uuid) {
        case '0000a00e-0000-1000-8000-00805f9b34fb': // StateInfo
            payload = {
                mjs: data.readUint8(0),
                mns: data.readUint8(1),
            }

            break
        case '0000a011-0000-1000-8000-00805f9b34fb': // Water level
            payload = {
                wl: data.readUint16BE() / 256 / 50, // 0-1 (50mm tank)
            }

            break
        case '0000a00a-0000-1000-8000-00805f9b34fb': // Temps
            payload = {
                wh: data.readUint16BE(0) / 256, // 1°C every 256
                sh: data.readUint16BE(2) / 256,
                gh: data.readUint16BE(4) / 256,
                cw: data.readUint16BE(6) / 256,
                twh: data.readUint16BE(8) / 256,
                tsh: data.readUint16BE(10) / 256,
                tgh: data.readUint16BE(12) / 256,
                tcw: data.readUint16BE(14) / 256,
            }

            break

        case '0000a00d-0000-1000-8000-00805f9b34fb': // Shot sample
            payload = {
                /* U16P12 */ ShotSampleTime: 0, // data.readUint16BE(0),
                /* U16P12 */ ShotGroupPressure: data.readUInt16BE(2) / (1 << 12),
                /* U16P12 */ ShotGroupFlow: data.readUint16BE(4) / (1 << 12),
                /* U16P8  */ ShotMixTemp: data.readUint16BE(6) / 0x100,
                /* U24P16 */ ShotHeadTemp: (data.readUint32BE(8) >> 8) / 0x10000,
                /* U16P8  */ ShotSetMixTemp: data.readUint16BE(11) / 0x100,
                /* U16P8  */ ShotSetHeadTemp: data.readUint16BE(13) / 0x100,
                /* U8P4   */ ShotSetGroupPressure: data.readUint8(15) / 0x10,
                /* U8P4   */ ShotSetGroupFlow: data.readUint8(16) / 0x10,
                /* U8P0   */ ShotFrameNumber: data.readUint8(17),
                /* U8P0   */ ShotSteamTemp: data.readUint8(18),
            }

            break
        default:
    }

    if (!payload) {
        return
    }

    Object.assign(properties, payload)

    wsServer.clients.forEach((ws) => {
        sendProperties(ws, payload)
    })
}

noble.on('discover', (device) => {
    const {
        state,
        advertisement: { localName },
    } = device

    if (localName !== 'DE1') {
        return
    }

    if (state !== 'disconnected') {
        return void info('DE1 found. State: %s. Doing nothing.', state)
    }

    info('DE1 found')

    device.once('connect', (err) => {
        if (err) {
            setState({
                connecting: false,
            })

            return void error('Connect failed: %s', err)
        }

        setState({
            discoveringCharacteristics: true,
        })

        device.discoverAllServicesAndCharacteristics(async (err, _, nextCharacteristics) => {
            if (err) {
                setState({
                    connecting: false,
                    discoveringCharacteristics: false,
                })

                return void error('discoverAllServicesAndCharacteristics failed: %s', err)
            }

            characteristics = {}

            nextCharacteristics.forEach((ch) => {
                characteristics[`0000${ch.uuid}-0000-1000-8000-00805f9b34fb`] = ch
            })

            setState({
                connecting: false,
                discoveringCharacteristics: false,
                device: JSON.parse(device.toString()),
            })

            const subs = [
                // StateInfo
                '0000a00e-0000-1000-8000-00805f9b34fb',
                // Water level
                '0000a011-0000-1000-8000-00805f9b34fb',
                // Temps
                '0000a00a-0000-1000-8000-00805f9b34fb',
                // Shot sample
                '0000a00d-0000-1000-8000-00805f9b34fb',
            ]

            for (let i = 0; i < subs.length; i++) {
                const uuid = subs[i]

                const char = characteristics[uuid]

                char.on('data', (data) => {
                    info('Data received', data)

                    setCharacteristicValue(uuid, data)
                })

                try {
                    await char.readAsync()

                    info(`Read ${uuid}`)

                    try {
                        await char.subscribeAsync()

                        info(`Subscribed to ${uuid}.`)
                    } catch (e) {
                        error('failed to subscribe')
                    }
                } catch (e) {
                    error('Failed to read', e)
                }
            }
        })

        info('Connected')

        connectedOnce = true
    })

    device.once('disconnect', (err) => {
        if (err) {
            return void error('Disconnect failed: %s', err)
        }

        setState({
            device: undefined,
        })

        info('Disconnected')

        // Start over!
        noble.startScanning([], false)
    })

    info('Connecting…')

    try {
        noble.stopScanning(() => {
            setState({
                connecting: true,
            })

            try {
                device.connect()
            } catch (e) {
                error('connect failed', e)
            }
        })
    } catch (e) {
        error('stopScanning failed', e)
    }
})

function writeCharacteristic(char, data) {
    return (_, res) => {
        const { device } = State

        if (!device) {
            return void res.status(409).json({ code: ErrorCode.NotConnected })
        }

        const characteristic = characteristics[char]

        if (!characteristic) {
            return void res.status(422).json({ code: ErrorCode.UnknownCharacteristic })
        }

        characteristic.write(data, false, (err) => {
            if (err) {
                error('`write` failed: %s', err)

                return void res.status(500).end()
            }

            res.status(200).end()
        })
    }
}

app.post('/on', writeCharacteristic('0000a002-0000-1000-8000-00805f9b34fb', Buffer.from([0x2])))

app.post('/off', writeCharacteristic('0000a002-0000-1000-8000-00805f9b34fb', Buffer.from([0x0])))

function sendState(webSocket) {
    webSocket.send(
        JSON.stringify({
            type: 'state',
            payload: State,
        })
    )
}

function setState(partial) {
    State = {
        ...State,
        ...partial,
    }

    wsServer.clients.forEach(sendState)
}

noble.on('stateChange', (state) => {
    setState({ bluetoothState: state })

    if (state !== 'poweredOn') {
        noble.stopScanning()
    }
})

noble.on('scanStart', () => {
    setState({ scanning: true })
})

noble.on('scanStop', () => {
    setState({ scanning: false })
})

wsServer.on('connection', (ws) => {
    info('New client')

    sendState(ws)

    sendProperties(ws, properties)

    ws.on('close', () => {
        info('Client disconnected')
    })

    ws.on('error', () => {
        error('Shit did happen')
    })

    ws.on('message', (data) => {
        info('Received %s', data)
    })
})
